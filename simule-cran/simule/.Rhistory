install.packages("devtools")
install.packages("roxygen2")
setwd("~/Dropbox/SVN/nonparaGM/codes/simule-cran/simule/")
library(devtools)
library(roxygen2)
library(simule)
library(simule)
library(simule)
library(simule)
library(e1071)
raw < - replicate(10, rpois(50,100))
raw.orig <- raw
rand.miss <- rdiscrete(50,probs=rep(1:length(raw)), values=seq(1,length(raw)) )
raw[rand.miss] <- NA
raw <- data.frame(raw)
var(na.omit(raw) )
var(raw.imputed)
EMalg <- function(x, tol=.001){
missvals <- is.na(x)
new.impute<-x
old.impute <- x
count.iter <- 1
reach.tol <- 0
sig <- as.matrix(var(na.exclude(x)))
mean.vec <- as.matrix(apply(na.exclude(x),2,mean))
while(reach.tol != 1) {
for(i in 1:nrow(x)) {
pick.miss <-( c( missvals[i,]) )
if ( sum(pick.miss) != 0 ) {
inv.S <- solve(sig[!pick.miss,!pick.miss]) # we need the inverse of the covariance
# Run the EM
new.impute[i,pick.miss] <- mean.vec[pick.miss] +
sig[pick.miss,!pick.miss] %*%
inv.S %*%
(t(new.impute[i,!pick.miss])- t(t(mean.vec[!pick.miss])))
}
}
sig <- var((new.impute))
mean.vec <- as.matrix(apply(new.impute,2,mean))
if(count.iter > 1){ # we don't want this to run on the first iteration or else if fails
for(l in 1:nrow(new.impute)){
for(m in 1:ncol(new.impute)){
if( abs((old.impute[l,m]-new.impute[l,m])) > tol ) {
reach.tol < - 0
} else {
reach.tol <- 1
}
}
}
}
count.iter <- count.iter+1 # used for debugging purposes to ensure process it iterating properly
old.impute <- new.impute
}
return(new.impute)
}
raw.imputed <- EMalg(raw, tol=.0001)
plot(raw.imputed[,1], raw.imputed[,2], pch=16, main="Scatterplot of Missing Data",
sub="Missing Values in Red", xlab="X",ylab="Y")
# overlay the imputed values on the plot
plot.imputed <- raw.imputed[
row.names(
subset(raw, is.na( raw[,2] ) | is.na( raw[,3]) )
),]
points(plot.imputed[,2],plot.imputed[,3], pch=16, col='red')
install.packages("e1071")
library(e1071)
raw < - replicate(10, rpois(50,100))
raw.orig <- raw
rand.miss <- rdiscrete(50,probs=rep(1:length(raw)), values=seq(1,length(raw)) )
raw[rand.miss] <- NA
raw <- data.frame(raw)
var(na.omit(raw) )
var(raw.imputed)
EMalg <- function(x, tol=.001){
missvals <- is.na(x)
new.impute<-x
old.impute <- x
count.iter <- 1
reach.tol <- 0
sig <- as.matrix(var(na.exclude(x)))
mean.vec <- as.matrix(apply(na.exclude(x),2,mean))
while(reach.tol != 1) {
for(i in 1:nrow(x)) {
pick.miss <-( c( missvals[i,]) )
if ( sum(pick.miss) != 0 ) {
inv.S <- solve(sig[!pick.miss,!pick.miss]) # we need the inverse of the covariance
# Run the EM
new.impute[i,pick.miss] <- mean.vec[pick.miss] +
sig[pick.miss,!pick.miss] %*%
inv.S %*%
(t(new.impute[i,!pick.miss])- t(t(mean.vec[!pick.miss])))
}
}
sig <- var((new.impute))
mean.vec <- as.matrix(apply(new.impute,2,mean))
if(count.iter > 1){ # we don't want this to run on the first iteration or else if fails
for(l in 1:nrow(new.impute)){
for(m in 1:ncol(new.impute)){
if( abs((old.impute[l,m]-new.impute[l,m])) > tol ) {
reach.tol < - 0
} else {
reach.tol <- 1
}
}
}
}
count.iter <- count.iter+1 # used for debugging purposes to ensure process it iterating properly
old.impute <- new.impute
}
return(new.impute)
}
raw.imputed <- EMalg(raw, tol=.0001)
plot(raw.imputed[,1], raw.imputed[,2], pch=16, main="Scatterplot of Missing Data",
sub="Missing Values in Red", xlab="X",ylab="Y")
# overlay the imputed values on the plot
plot.imputed <- raw.imputed[
row.names(
subset(raw, is.na( raw[,2] ) | is.na( raw[,3]) )
),]
points(plot.imputed[,2],plot.imputed[,3], pch=16, col='red')
library(e1071)
raw < - replicate(10, rpois(50,100))
rpois(50, 100)
raw <- replicate(10, rpois(50,100))
raw <- replicate(10, rpois(50,100))
raw <- replicate(10, rpois(50,100))
raw <- replicate(10, rpois(50,100))
raw.orig <- raw
rand.miss <- rdiscrete(50,probs=rep(1:length(raw)), values=seq(1,length(raw)) )
raw[rand.miss] <- NA
raw <- data.frame(raw)
var(na.omit(raw) )
var(raw.imputed)
EMalg <- function(x, tol=.001){
missvals <- is.na(x)
new.impute<-x
old.impute <- x
count.iter <- 1
reach.tol <- 0
sig <- as.matrix(var(na.exclude(x)))
mean.vec <- as.matrix(apply(na.exclude(x),2,mean))
while(reach.tol != 1) {
for(i in 1:nrow(x)) {
pick.miss <-( c( missvals[i,]) )
if ( sum(pick.miss) != 0 ) {
inv.S <- solve(sig[!pick.miss,!pick.miss]) # we need the inverse of the covariance
# Run the EM
new.impute[i,pick.miss] <- mean.vec[pick.miss] +
sig[pick.miss,!pick.miss] %*%
inv.S %*%
(t(new.impute[i,!pick.miss])- t(t(mean.vec[!pick.miss])))
}
}
sig <- var((new.impute))
mean.vec <- as.matrix(apply(new.impute,2,mean))
if(count.iter > 1){ # we don't want this to run on the first iteration or else if fails
for(l in 1:nrow(new.impute)){
for(m in 1:ncol(new.impute)){
if( abs((old.impute[l,m]-new.impute[l,m])) > tol ) {
reach.tol < - 0
} else {
reach.tol <- 1
}
}
}
}
count.iter <- count.iter+1 # used for debugging purposes to ensure process it iterating properly
old.impute <- new.impute
}
return(new.impute)
}
raw.imputed <- EMalg(raw, tol=.0001)
raw
raw.imputed
x7 = EMalg(xna, tol=.001)
library("softImpute")
#library("mice")
n = 100
N = 2
p = 200
I = diag(1,p,p)
Covs = list()
X = list()
graphs = simulateGraph(p,N)
for(i in 1:N){
Covs[[i]] = solve(graphs[[i]], I)
X[[i]] = mvrnorm(n,mu = rep(0,p),Covs[[i]])
}
transNA <- function(x){
if (x < 1){
return(NA)
}
else{
return(1)
}
}
zeroImpute <- function(x){
x[which(is.na(x))] = 0
return(x)
}
medianImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = median(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
meanImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = mean(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
#set.seed(37)
#mask = runif(n*p, 0,5)
#mask = array(mask, dim=c(n,p))
#mask = apply(mask, c(1,2), transNA)
mask = matrix(1,n,p)
for(i in 1:50){
for(j in 151:200){
mask[i,j] = NA
}
}
for(i in 51:100){
for(i in 1:50){
mask[i,j] = NA
}
}
xna = mask * X[[1]]
x1 = zeroImpute(xna)
cov1 = cov(x1)
x2 = medianImpute(xna)
cov2 = cov(x2)
x3 = meanImpute(xna)
cov3 = cov(x3)
install.packages("softImpute")
library("softImpute")
#library("mice")
n = 100
N = 2
p = 200
I = diag(1,p,p)
Covs = list()
X = list()
graphs = simulateGraph(p,N)
for(i in 1:N){
Covs[[i]] = solve(graphs[[i]], I)
X[[i]] = mvrnorm(n,mu = rep(0,p),Covs[[i]])
}
transNA <- function(x){
if (x < 1){
return(NA)
}
else{
return(1)
}
}
zeroImpute <- function(x){
x[which(is.na(x))] = 0
return(x)
}
medianImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = median(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
meanImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = mean(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
#set.seed(37)
#mask = runif(n*p, 0,5)
#mask = array(mask, dim=c(n,p))
#mask = apply(mask, c(1,2), transNA)
mask = matrix(1,n,p)
for(i in 1:50){
for(j in 151:200){
mask[i,j] = NA
}
}
for(i in 51:100){
for(i in 1:50){
mask[i,j] = NA
}
}
xna = mask * X[[1]]
#simulate multiple sparse graphs
simulateGraph <- function(p = 100, N = 2, seedNum = 37,s = 1){
library(MASS)
#set parameters
# p = 1000
# N = 3
set.seed(seedNum)
graphs <- list()
I = diag(1,p,p)
graph_shared = matrix(1,p,p)
for(j in 1:p){
for(k in j:p){
graph_shared[j,k] = 0.5 * rbinom(1,1, 0.1* s)
graph_shared[k,j] = graph_shared[j,k]
}
}
#generate the simulate graph
#first one is the all off diag element has 0.1*N to be 0.5 and others to be 0
for(i in 1:N){
graphs[[i]] <- matrix(1,p,p)
}
for(i in 1:N){
for(j in 1:p){
for(k in j:p){
graphs[[i]][j,k] = 0.5 * rbinom(1,1, 0.01* N)
graphs[[i]][k,j] = graphs[[i]][j,k]
}
}
graphs[[i]] = graphs[[i]] + graph_shared
}
for(i in 1:N){
for(j in 1:p){
graphs[[i]][j,j] = 1
}
}
for(i in 1:N){
graphs[[i]] = (graphs[[i]] - I) + (abs(min(eigen(graphs[[i]] - I)$value))+1) * I
}
graphs[[N + 1]] = graph_shared
graphs
}
library("softImpute")
#library("mice")
n = 100
N = 2
p = 200
I = diag(1,p,p)
Covs = list()
X = list()
graphs = simulateGraph(p,N)
for(i in 1:N){
Covs[[i]] = solve(graphs[[i]], I)
X[[i]] = mvrnorm(n,mu = rep(0,p),Covs[[i]])
}
transNA <- function(x){
if (x < 1){
return(NA)
}
else{
return(1)
}
}
zeroImpute <- function(x){
x[which(is.na(x))] = 0
return(x)
}
medianImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = median(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
meanImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = mean(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
#set.seed(37)
#mask = runif(n*p, 0,5)
#mask = array(mask, dim=c(n,p))
#mask = apply(mask, c(1,2), transNA)
mask = matrix(1,n,p)
for(i in 1:50){
for(j in 151:200){
mask[i,j] = NA
}
}
for(i in 51:100){
for(i in 1:50){
mask[i,j] = NA
}
}
xna = mask * X[[1]]
x1 = zeroImpute(xna)
cov1 = cov(x1)
x2 = medianImpute(xna)
cov2 = cov(x2)
x3 = meanImpute(xna)
cov3 = cov(x3)
x7 = EMalg(xna, tol=.001)
library("irlba", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
