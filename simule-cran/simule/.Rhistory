#generate the simulate graph
#first one is the all off diag element has 0.1*N to be 0.5 and others to be 0
for(i in 1:N){
graphs[[i]] <- matrix(1,p,p)
}
for(i in 1:N){
for(j in 1:p){
for(k in j:p){
graphs[[i]][j,k] = 0.5 * rbinom(1,1, 0.01* N)
graphs[[i]][k,j] = graphs[[i]][j,k]
}
}
graphs[[i]] = graphs[[i]] + graph_shared
}
for(i in 1:N){
for(j in 1:p){
graphs[[i]][j,j] = 1
}
}
for(i in 1:N){
graphs[[i]] = (graphs[[i]] - I) + (abs(min(eigen(graphs[[i]] - I)$value))+1) * I
}
graphs[[N + 1]] = graph_shared
graphs
}
library("softImpute")
#library("mice")
n = 100
N = 2
p = 200
I = diag(1,p,p)
Covs = list()
X = list()
graphs = simulateGraph(p,N)
for(i in 1:N){
Covs[[i]] = solve(graphs[[i]], I)
X[[i]] = mvrnorm(n,mu = rep(0,p),Covs[[i]])
}
transNA <- function(x){
if (x < 1){
return(NA)
}
else{
return(1)
}
}
zeroImpute <- function(x){
x[which(is.na(x))] = 0
return(x)
}
medianImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = median(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
meanImpute <- function(x){
n = nrow(x)
p = ncol(x)
for (i in 1:n){
for (j in 1:p){
if(is.na(x[i,j])){
x[i,j] = mean(x[-which(is.na(x[,j])),j])
}
}
}
return(x)
}
#set.seed(37)
#mask = runif(n*p, 0,5)
#mask = array(mask, dim=c(n,p))
#mask = apply(mask, c(1,2), transNA)
mask = matrix(1,n,p)
for(i in 1:50){
for(j in 151:200){
mask[i,j] = NA
}
}
for(i in 51:100){
for(i in 1:50){
mask[i,j] = NA
}
}
xna = mask * X[[1]]
x1 = zeroImpute(xna)
cov1 = cov(x1)
x2 = medianImpute(xna)
cov2 = cov(x2)
x3 = meanImpute(xna)
cov3 = cov(x3)
x7 = EMalg(xna, tol=.001)
library("irlba", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library(simule)
isSymmetric(X)
library(simule)
load(exampleData)
data(exampleData)
library(simule)
library(simule)
library(simule)
library(simule)
library(simule)
data(exampleData)
X
tmp = cov(X[[1]])
summary(X)
format(X)
load("~/Github/SIMULE/simule-cran/simule/data/exampleData.rda")
X
exampleData = X
save(exampleData, "exampleData.rda")
save(exampleData, file = "exampleData.rda")
R CMD
check -- as cran
devtools::check()
FALSE
FASLE
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
library("simule", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
demo
demo()
demo(simuleDemo)
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
demo(simuleDemo)
load("~/Github/SIMULE/simule-cran/simule/data/exampleData.rda")
exampleData
colnames(exampleData[[1]]) = 1:200
1:200
colnames(exampleData[[1]]) = 1:100
rownames(exampleData[[1]]) = 1:200
colnames(exampleData[[2]]) = 1:100
rownames(exampleData[[2]]) = 1:200
save(exampleData, filename = "exampleData.rda")
save(exampleData, file = "exampleData.rda")
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
demo(simuleDemo)
theta = results$Graphs
index = 50
K = length(theta)
p = dim(theta[[1]])[1]
neighbors = list()
for(k in 1:K)
{
neighbor.indices = (theta[[k]][index,]!=0)
neighbor.indices[index] = FALSE
neighbors[[k]] = row.names(theta[[1]])[neighbor.indices]
}
return(neighbors)
net.neighbors <-
function(theta,index)
{
#index = (row.names(theta[[1]])==name)
K = length(theta)
p = dim(theta[[1]])[1]
neighbors = list()
for(k in 1:K)
{
neighbor.indices = (theta[[k]][index,]!=0)
neighbor.indices[index] = FALSE
neighbors[[k]] = row.names(theta[[1]])[neighbor.indices]
}
return(neighbors)
}
for(k in 1:K)
{
neighbor.indices = (theta[[k]][index,]!=0)
neighbor.indices[index] = FALSE
neighbors[[k]] = row.names(theta[[1]])[neighbor.indices]
}
neighbor.indices
neighbor.indices = (theta[[k]][index,]!=0)
neighbor.indices
neighbor.indices = which(theta[[k]][index,]!=0)
neighbor.indices
neighbors[[k]] = row.names(theta[[1]])[neighbor.indices]
neighbors = list()
for(k in 1:K)
{
neighbor.indices = which(theta[[k]][index,]!=0)
#neighbor.indices[index] = FALSE
neighbors[[k]] = row.names(theta[[1]])[neighbor.indices]
}
neighbors = list()
for(k in 1:K)
{
neighbor.indices = which(theta[[k]][index,]!=0)
#neighbor.indices[index] = FALSE
neighbors[[k]] = rownames(theta[[1]])[neighbor.indices]
}
rownames(theta[[1]])[neighbor.indices]
rownames(theta[[1]])
theta[[1]]
for(k in 1:K)
{
neighbors[[k]] = which(theta[[k]][index,]!=0)
}
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
demo(simuleDemo)
net.neighbors(results$Graphs,index=50)
K = length(theta)
p = dim(theta[[1]])[1]
neighbors = list()
for(k in 1:K)
{
neighbors[[k]] = which(theta[[k]][index,]!=0)
}
net.neighbors()
net.neighbors
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
net.neighbors()
net.neighbors
a = matrix(1,3,3)
b = matrix(2,3,3)
a * b
dim(a)
rep(1,3)
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
detach("package:simule", unload=TRUE)
library("simule", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
demo(simuleDemo)
#A simplex solver for linear programming problem in (N)SIMULE
.linprogSPar <- function(i, Sigma, lambda){
# num of p * N
# pTimesN = nrow(Sigma)
# num of p * (N + 1)
# Get parameters
q = ncol(Sigma)
p = ncol(Sigma) - nrow(Sigma)
N = nrow(Sigma) / p
# Generate e_j
e = rep(0, p * N)
for(j in 1:N){
e[i + (j - 1) * p] = 1
}
# linear programming solution
f.obj = rep(1, 2 * q)
con1 = cbind(-Sigma, +Sigma)
b1 = lambda - e
b2 =  lambda + e
f.con = rbind(-diag(2 * q), con1, -con1)
f.dir = rep("<=", 4 * q)
f.rhs = c(rep(0, 2 * q), b1, b2)
lp.out = lp("min", f.obj, f.con, f.dir, f.rhs)
beta = lp.out$solution[1:q] - lp.out$solution[(q + 1):(2 * q)]
if (lp.out$status == 2) warning("No feasible solution!  Try a larger tuning parameter!")
return(beta)
}
# (N)SIMULE implementation
simule <- function(X, lambda, epsilon = 1, covType = "cov",parallel = FALSE ){
#get number of tasks
N = length(X)
#get the cov/cor matrices
if (isSymmetric(X[[1]]) == FALSE){
try(if (covType %in% c("cov","kendall") == FALSE) stop("The cov/cor type you specifies is not include in this package. Please use your own function to obtain the list of cov/cor and use them as the input of simule()"))
if (covType == "cov"){
for (i in 1:N){
X[[i]] = cov(X[[i]])
}
}
if (covType == "kendall"){
for(i in 1:N){
X[[i]] = cor.fk(X[[i]])
}
}
}
# initialize the parameters
Graphs = list()
p = ncol(X[[1]])
xt = matrix(0, (N + 1) * p, p)
I = diag(1, p, p)
Z = matrix(0, p, p)
# generate the condition matrix A
A = X[[1]]
for(i in 2:N){
A = cbind(A,Z)
}
A = cbind(A,(1/N)*X[[1]])
for(i in 2:N){
temp = Z
for(j in 2:N){
if (j == i){
temp = cbind(temp,X[[i]])
}
else{
temp = cbind(temp,Z)
}
}
temp = cbind(temp, 1/(epsilon * N) * X[[i]])
A = rbind(A, temp)
}
# define the function f for parallelization
f = function(x) .linprogSPar(x, A, lambda)
if(parallel == TRUE){ # parallel version
# number of cores to collect,
# default number is number cores in your machine - 1,
# you can set your own number by changing this line.
no_cores = detectCores() - 1
cl = makeCluster(no_cores)
# declare variable and function names to the cluster
clusterExport(cl, list("f", "A", "lambda", ".linprogSPar", "lp"), envir = environment())
result = parLapply(cl, 1:p, f)
#print('Done!')
for (i in 1:p){
xt[,i] = result[[i]]
}
stopCluster(cl)
}else{ # single machine code
for (i in 1 : p){
xt[,i] = f(i)
if (i %% 10 == 0){
cat("=")
if(i %% 100 == 0){
cat("+")
}
}
}
print("Done!")
}
for(i in 1:N){
# combine the results from each column. (\hat{\Omega}_{tot}^1)
Graphs[[i]] = xt[(1 + (i-1) * p):(i * p),] + 1/(epsilon * N) * xt[(1 + N * p):((N + 1) * p),]
# make it be symmetric
for(j in 1:p){
for(k in j:p){
if (abs(Graphs[[i]][j,k]) < abs(Graphs[[i]][k,j])){
Graphs[[i]][j,k] = Graphs[[i]][j,k]
Graphs[[i]][k,j] = Graphs[[i]][j,k]
}
else{
Graphs[[i]][j,k] = Graphs[[i]][k,j]
Graphs[[i]][k,j] = Graphs[[i]][k,j]
}
}
}
}
out = list(Graphs = Graphs)
class(out) = "simule"
return(out)
}
plot.simule <-
function(x, type="graph", subID=NULL, index=NULL, ...)
{
.env = "environment: namespace:simule"
#UseMethod("plot")
tmp = x$Graphs
Graphs = list()
if (type == "share"){
Graphs[[1]] = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
Graphs[[1]] = Graphs[[1]] & tmp[[i]]
}
Graphs[[1]] = as.numeric(Graphs[[1]])
}
if (type == "sub"){
temp = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
temp = temp & tmp[[i]]
}
temp = !temp
temp = as.numeric(temp)
Graphs[[1]] = tmp[[subID]] * temp
}
if (type == "graph"){
Graphs = tmp
}
if (type == "neighbor"){
p = dim(tmp[[1]])[1]
id = matrix(0,p,p)
id[index,] = rep(1,p)
id[,index] = rep(1,p)
for (i in 1:length(tmp)){
Graphs[[i]] = tmp[[i]] * id
}
}
K=length(Graphs)
adj = .make.adj.matrix(Graphs)
diag(adj)=0
gadj = graph.adjacency(adj,mode="upper",weighted=TRUE)
#weight the edges according to the classes they belong to
E(gadj)$color = 2^(K)-get.edge.attribute(gadj,"weight")
#plot the net using igraph
plot(gadj, vertex.frame.color="white",layout=layout.fruchterman.reingold,
vertex.label=NA, vertex.label.cex=3, vertex.size=1)
}
.make.adj.matrix <-
function(theta, separate=FALSE)
{
K = length(theta)
adj = list()
if(separate)
{
for(k in 1:K)
{
adj[[k]] = (abs(theta[[k]])>1e-5)*1
}
}
if(!separate)
{
adj = 0*theta[[1]]
for(k in 1:K)
{
adj = adj+(abs(theta[[k]])>1e-5)*2^(k-1)
}
}
return(adj)
}
plot.simule(results, type="share")
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
detach("package:simule", unload=TRUE)
library("simule", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
demo(simuleDemo)
demo(simuleDemo)
detach("package:simule", unload=TRUE)
library("simule", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
demo(simuleDemo)
demo(simuleDemo)
tmp = results$Graphs
Graphs = list()
type = "share"
if (type == "share"){
Graphs[[1]] = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
Graphs[[1]] = Graphs[[1]] & tmp[[i]]
}
Graphs[[1]] = as.numeric(Graphs[[1]])
}
Graphs[[1]]
if (type == "share"){
Graphs[[1]] = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
Graphs[[1]] = Graphs[[1]] & tmp[[i]]
}
Graphs[[1]] = matrix(as.numeric(Graphs[[1]]), p, p)
}
p = dim(tmp[[1]])[1]
if (type == "share"){
Graphs[[1]] = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
Graphs[[1]] = Graphs[[1]] & tmp[[i]]
}
Graphs[[1]] = matrix(as.numeric(Graphs[[1]]), p, p)
}
Graphs[[1]]
K=length(Graphs)
adj = .make.adj.matrix(Graphs)
diag(adj)=0
gadj = graph.adjacency(adj,mode="upper",weighted=TRUE)
#weight the edges according to the classes they belong to
E(gadj)$color = 2^(K)-get.edge.attribute(gadj,"weight")
#plot the net using igraph
plot(gadj, vertex.frame.color="white",layout=layout.fruchterman.reingold,
vertex.label=NA, vertex.label.cex=3, vertex.size=1)
type = "sub"
subID =1
if (type == "sub"){
temp = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
temp = temp & tmp[[i]]
}
temp = !temp
temp = matrix(as.numeric(temp, p, p))
Graphs[[1]] = tmp[[subID]] * temp
}
dim(temp)
if (type == "sub"){
temp = tmp[[1]] & tmp[[2]]
for (i in 2:length(tmp)){
temp = temp & tmp[[i]]
}
temp = !temp
temp = matrix(as.numeric(temp), p, p)
Graphs[[1]] = tmp[[subID]] * temp
}
Graphs[[1]]
K=length(Graphs)
adj = .make.adj.matrix(Graphs)
diag(adj)=0
gadj = graph.adjacency(adj,mode="upper",weighted=TRUE)
#weight the edges according to the classes they belong to
E(gadj)$color = 2^(K)-get.edge.attribute(gadj,"weight")
#plot the net using igraph
plot(gadj, vertex.frame.color="white",layout=layout.fruchterman.reingold,
vertex.label=NA, vertex.label.cex=3, vertex.size=1)
type = "neighbor"
index =50
if (type == "neighbor"){
id = matrix(0,p,p)
id[index,] = rep(1,p)
id[,index] = rep(1,p)
for (i in 1:length(tmp)){
Graphs[[i]] = tmp[[i]] * id
}
}
K=length(Graphs)
adj = .make.adj.matrix(Graphs)
diag(adj)=0
gadj = graph.adjacency(adj,mode="upper",weighted=TRUE)
#weight the edges according to the classes they belong to
E(gadj)$color = 2^(K)-get.edge.attribute(gadj,"weight")
#plot the net using igraph
plot(gadj, vertex.frame.color="white",layout=layout.fruchterman.reingold,
vertex.label=NA, vertex.label.cex=3, vertex.size=1)
install.packages("~/Github/SIMULE/simule-cran/simule_1.1.1.tar.gz", repos = NULL, type = "source")
detach("package:simule", unload=TRUE)
library("simule", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
demo(simuleDemo)
