
par(mfrow=c(2,2))


### some setup code
{
data(cancer)

## create a list of cancer data
X = list(as.matrix(cancer[[1]][which(cancer[[2]] == "not"),]),
         as.matrix(cancer[[1]][which(cancer[[2]] == "pcr"),]))

### run simule
results = simule(X, 0.2, 1, covType = "cov", TRUE)
cancername = colnames(cancer[[1]])
cancergraph = return.simule(results, option = "igraph")
}


### general testing for 2D, 3D, interactive mode
{

pdf("sample.pdf", width = 20, height = 20)

par(mfrow=c(2,2))

cancerlayout = layout_nicely(cancergraph,dim=3)

plot.simule(results, option = "2D", graphlabel = cancername, type="graph", graphlayout = cancerlayout)


plot.simule(results, option = "2D", graphlabel = cancername, type="share", graphlayout = cancerlayout)


### plot the estimated task-specific graph whose task index="sub" by simule
plot.simule(results, option = "2D", graphlabel = cancername, type="sub", subID=1, graphlayout = cancerlayout)


### plot the estimated subgraphs that is about a specific node
plot.simule(results, option = "2D", graphlabel = cancername, type="sub", subID=2, graphlayout = cancerlayout)

dev.off()
}



### test for neighbor plot for different subgraph
{
par(mfrow=c(2,2))

plot.simule(results, option = "2D", graphlabel = cancername, type = "neighbor", index = c(1,2,3),  graphlayout = NULL)

plot.simule(results, option = "2D", graphlabel = cancername, type = "neighbor", index = c(1), subID = 0, graphlayout = NULL)

plot.simule(results, option = "2D", graphlabel = cancername, type = "neighbor", index = c(1), subID = 1, graphlayout = NULL)

plot.simule(results, option = "2D", graphlabel = cancername, type = "neighbor", index = c(1), subID = 2, graphlayout = NULL)


}


### test for edge color
gadj = return.simule(results, option = "igraph", type = "graph", subID = NULL, index = NULL)
adj = return.simule(results, option = "adjmatrix", type = "graph", subID = NULL, index = NULL)

edge_attr(gadj,"weight",index = E(gadj))
get.edge.attribute(gadj,"weight")
E(gadj)$color = edge_attr(gadj,"weight",index = E(gadj))
E(gadj)$color = 0.2
E(gadj)$color = E(gadj)$color * 12
E(gadj)$color
2^(K)-edge_attr(gadj,"weight",index = E(gadj))

par(mfrow=c(2,2))

plot.igraph(gadj, edge.color = get.edge.attribute(gadj,"weight"))

plot.igraph(gadj, edge.color = "#E69F00" )

plot.igraph(gadj, edge.color = "#56B4E9" )

plot.igraph(gadj, edge.color = "#009E73" )

plot.igraph(gadj, edge.color = 1 )

plot.igraph(gadj, edge.color = 9 )

plot.igraph(gadj, edge.color = 2.2)

K = 2

legend("topleft" , legend = c(paste("individual",c(1:K)), "share"),
       col = categorical_pal(K+1), pch = 16)
### testing on neightbourhood plotting
{
x = results
tmp = x$Graphs
Graphs = list()
p = dim(tmp[[1]])[1]
Graphs = temp

if (FALSE){
index = 2
{
id = matrix(0,p,p)
id[index,] = rep(1,p)
id[,index] = rep(1,p)
for (i in 1:length(tmp)){
  Graphs[[i]] = tmp[[i]] * id
}
}
}


K=length(Graphs)
adj <- .make.adj.matrix(Graphs)
diag(adj)=0

  #colnames(adj) <- name
  #rownames(adj) <- name
  #gadj = graph_from_adjacency_matrix(adj,mode="upper",weighted=TRUE, add.colnames = 'name')
gadj = graph_from_adjacency_matrix(adj,mode="upper",weighted=TRUE)
E(gadj)$color = 2^(K)-get.edge.attribute(gadj,"weight")

plot(gadj)
}


### timing code
{
start_time = Sys.time()
end_time = Sys.time()
print(paste("the time taken for DIFFEE to run:", end_time - start_time))
}


## generate precision matrix
library(MASS)
library(boot)

simulateGraph <- function(p = 20, N = 2, W = matrix(1,20,20), s = 0.01, seedNum = 37){
  library(MASS)
  #set parameters
  # p = 1000
  # N = 3
  set.seed(seedNum)
  graphs <- list()
  I = diag(1,p,p)
  graph_shared = matrix(1,p,p)
  for (j in 1:p) {
    for (k in j:p) {

      graph_shared[j,k] = 0.5 * rbinom(1,1, 0.5 * inv.logit(10-(W[j,k]/3)))
      graph_shared[k,j] = graph_shared[j,k]

    }
  }
  #generate the simulate graph
  #first one is the all off diag element has 0.1*N to be 0.5 and others to be 0
  for (i in 1:N) {
    graphs[[i]] <- matrix(1,p,p)
  }
  for (i in 1:N) {
    for (j in 1:p) {
      for (k in j:p) {

        graphs[[i]][j,k] = 0.5 * rbinom(1,1, s *inv.logit(10- (W[j,k]/3)))
        graphs[[i]][k,j] = graphs[[i]][j,k]
        if (i == 2 & (j + k) %% 2 == 1){
          graphs[[i]][j,k] = 0.5 * rbinom(1,1, 0.1 + s *inv.logit(10- (W[j,k]/3)))
          graphs[[i]][k,j] = graphs[[i]][j,k]
        }
      }
    }
    graphs[[i]] = graphs[[i]] + graph_shared
  }


  for (i in 1:N) {
    for (j in 1:p) {
      graphs[[i]][j,j] = 1
    }
  }
  for (i in 1:N) {
    graphs[[i]] = (graphs[[i]] - I) + (abs(min(eigen(graphs[[i]] - I)$value)) + 1) * I
  }
  graphs[[N + 1]] = graph_shared
  return(graphs)
}
